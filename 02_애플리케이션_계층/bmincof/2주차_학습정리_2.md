# 04. Transport layer

**Transport layer**

TCP의 reliable한 데이터 전송이 어떻게 이루어지는지?

transport의 하위 계층은 사실 unreliable함

-> 패킷 유실되거나 패킷 에러가 발생함

-> 이 2가지 상황만 잘 처리하면 reliable하게 만들 수 있다.

한 번에 패킷 하나씩 보내고 반대편에서 다 받았으면 남은 패킷 보내기 반복

***이상적인 상황부터 프로토콜 설계해보기***

**Rdt1.0** : 데이터 전송이 유실도 없고 에러도 없는 상황을 가정(완벽하게 전송됨)

고려할 것이 없음

비현실적인 상황

**Rdt2.0** : 패킷 에러만 발생할 수 있는 통신 상황 가정

에러가 났는지 안났는지 구분할 방법이 필요(checksum을 이용)

에러가 있었는지(NAK) 없었는지(ACK) 피드백해주기

-> 에러 DETECTION, 피드백, 재전송 기능 필요

**Rdt2.1** :
전송 받고 피드백 보냈을 때 에러가 발생한다면? 

제대로 판단 불가능

정확한 판단을 못하니까 패킷을 재전송

재전송한 패킷을 리시버 입장에서 중복된 패킷인지 구분할 방법이 없음

-> 패킷에 순서대로 번호를 붙여서 해결 (시퀀스 넘버를 모든 패킷에 붙이기)

-> 헤더에 포함되는 시퀀스 넘버가 너무 커질 수 있음 (시퀀스 넘버가 차지하는 크기가 데이터에 비해 매우 커질 수 있다)

-> 부가적인 정보를 최소화 시키고 싶음(한 번에 패킷 하나만 보내므로 시퀀스 넘버 2개만 있으면 중복 구분 가능 = 1 bit)

**Rdt2.2** : NAK-free protocol

에러가 발생하면 정상적으로 받은 마지막 패킷 넘버를 ACK에 담아서 보냄

**Rdt3.0** : 패킷 에러, 로스 가능
로스됐는지 확인할 타이머가 필요 (유실됐으면 피드백이 없으니까)

-> 그러면 얼마나 기다려야 하는가? 정답이 없음(정확히 수치화하기 힘듦, 트레이드오프 존재)

이런 정보들이 패킷의 TCP Header에 있음

Rdt라는 프로토콜은 너무 단순함 (패킷 하나 보낼 때마다 확인하는 방식)

-> 패킷 하나 보내고 응답 받을 때까지 통신을 안함

-> 자원을 제대로 이용하지 못함
